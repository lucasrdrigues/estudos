# Servidor cache - usaremos diretiva: proxy_cache_path. A pasta para armazenar o cache é da nossa escolha, essa pasta pode ser
# compartilhada entre outros servidores também, por isso é uma boa prática usar níveis na pasta.
# Poderiamos usar outros parametros abaixo, mas depende de cada situação.
# fastcgi_cache_path + path para armazenar o cache + levels=1:2(divisão da pasta) + keys_zone=nome escolhido:tamanho do armazenamento;
# o keys_zone é o nome de uma área da memória compartilhada dentro desta instância do nginx, este nome é o identificador lógico dela.
fastcgi_cache_path /tmp/cache levels=1:2 keys_zone=fpm:10m;
# Quando a resposta estiver cacheada, ele ficará dentro da pasta escolhida, caso ela não exista, o nginx irá criá-la.

server {
	listen 8004;

	# Cuidado: como o php fpm esta em um container, devemos colocar o caminho absoluto do arquivo no container
	root /caminho/projeto;				

	location / {
		include fastcgi.conf;		
		# O arquivo de fastcgi tem todos os parâmetros para passados nele para que a comunicação aconteça,
		# por isso precisamos importar ele acima

		# Disponibilizando o servidor como cache
		# fastcgi_cache + nome da zona
		fastcgi_cache fpm;

		# “Etiqueta única” que o Nginx usa para identificar o cache de cada requisição. 
		# É a fórmula que o Nginx usa para gerar esse identificador único para cada requisição. Se duas requisições gerarem
		# a mesma chave, elas vão compartilhar o mesmo cache, se for chaves diferentes, ele irá armazenar respostas separadas.
		fastcgi_cache_key $request_method$request_uri;

		# Definindo o que cachear de acordo com o status e por quanto tempo:
		# Usa somente o padrão que seria as respostas com status 200, 301 e 302.
		# Caso queira cachear apenas respostas especificas use fastcgi_cache_valid 200 302 10m;
		# Caso queira cacher tudo use fastcgi_cache_valid any 10m;
		fastcgi_cache_valid 1m;
		# As resposta com o status padrão ficam 1 minuto no cache(para usar hora use 1h)

		# Adicionando cabeçalho http personalizado para puxarmos o status da req, isso nos serve na hora de realizar testes
		# $upstream cache status -> status do cache do upstream configurado(caso tivessemos usando load balance, seria ele
		# mas estamos usando fastcgi, entretando o nome da variavel continua sendo o mesmo)
		add_header X-Cache-Status $upstream_cache_status;
		# Irá retornar HIT(quando o conteúdo for cacheado(pego do servidor), EXPIRED(havia cache mas estava expirado
		# entao o nginx pediu para o servidor da aplicação, ou seja, não foi cacheado), MISS(quando nao tinha arquivo
		# para cache no servidor cache))		

		# O arquivo de configs do fastcgi é o fastcgi.conf, mas vamos modificar as variáveis por aqui mesmo
		# Caso não esteja achando o arquivo, tente forçar o caminho e o nome do arquivo index usando:
		fastcgi_param SCRIPT_FILENAME /caminho/projeto$fastcgi_script_name;
		fastcgi_index index.php;
		
		# Jogando para o php fpm que esta na porta 9000(neste caso esta em um container mapeado na porta 9000)
		fastcgi_pass localhost:9000;
	}
}
